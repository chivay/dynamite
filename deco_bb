#!/usr/bin/env python3

# Copyright 2017 CodiLime
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse

parser = argparse.ArgumentParser(description='Decompile a list of basic blocks.')
parser.add_argument('file', help='the input file')
parser.add_argument('-a', '--print-assembly', action='store_true', help='print the assembly insns')
parser.add_argument('-A', '--print-assembly-sema', action='store_true', help='print the assembly insns with semantics')
args = parser.parse_args()

from veles.data.bindata import BinData
from veles.dis.isa.falcon import FalconIsa
from veles.deco.bb import BasicBlock

data = None
base = None

isa = FalconIsa()

def do_bb(name, start, end):
    bb = BasicBlock({}, data, base, None, isa, start, end)
    print("BB {}:".format(name))
    for insn in bb.insns:
        if args.print_assembly or args.print_assembly_sema:
            print('{:08x} {:18} {}'.format(insn.start, ' '.join(format(x, '02x') for x in data[insn.start:insn.end]), (' '*28 + '\n').join(str(x) for x in insn.insns)))
        if args.print_assembly_sema:
            print(insn.sema.str(0))
    if args.print_assembly and not args.print_assembly_sema:
        print()
    print(bb.sema.str(0))
    for name, val in bb.regstate.items():
        print('${} = {}'.format(name, val))
    print()
    if bb.nextpc is not None:
        print('goto {}'.format(bb.nextpc))
    print()

bb_name = None
bb_start = None
bb_end = None

def flush_bb():
    global bb_name, bb_start, bb_end
    if bb_name is None:
        return
    do_bb(bb_name, bb_start, bb_end)
    bb_name= None
    bb_start = None
    bb_end = None

with open(args.file) as f:
    for l in f:
        l, _, _ = l.partition('#')
        p = l.split()
        if not p:
            continue
        cmd = p[0]
        if data is None:
            if cmd != 'file':
                raise ValueError('Expecting a file command')
            if len(p) not in {2, 3, 5}:
                raise ValueError('File command needs 1, 2, or 4 arguments')
            if len(p) > 2:
                base = int(p[2], 16)
            else:
                base = 0
            with open(p[1], "rb") as df:
                if len(p) > 3:
                    df.seek(int(p[3], 16))
                    sz = int(p[4], 16)
                    data = df.read(sz)
                    if len(data) != sz:
                        raise ValueError('not enough data in the file')
                else:
                    data = df.read()
                data = BinData(8, data)
        else:
            if cmd == 'bb':
                flush_bb()
                if len(p) not in {3, 4}:
                    raise ValueError('bb command needs 2 or 3 arguments')
                bb_name = p[1]
                bb_start = int(p[2], 16)
                if len(p) < 4:
                    bb_end = None
                else:
                    bb_end = int(p[3], 16)
            else:
                raise ValueError('Unknown command "{}"'.format(cmd))

flush_bb()
