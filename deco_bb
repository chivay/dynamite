#!/usr/bin/env python3

# Copyright 2017 CodiLime
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse

parser = argparse.ArgumentParser(description='Decompile a list of basic blocks.')
parser.add_argument('file', help='the input file')
parser.add_argument('-a', '--print-assembly', action='store_true', help='print the assembly insns')
parser.add_argument('-A', '--print-assembly-sema', action='store_true', help='print the assembly insns with semantics')
args = parser.parse_args()

from veles.data.bindata import BinData
from veles.dis.isa.falcon import FalconIsa
from veles.dis.sema import (
    SemaList, SemaSet, SemaReadReg, SemaWriteReg, SemaIfElse,
    SemaExtr, SemaConst, SemaVar,
)
from veles.dis.reg import (
    Register, RegisterSP, RegisterPC, RegisterObservable, RegisterSplit, SubRegister,
    RegisterSpecial,
)

data = None
base = None

isa = FalconIsa()

class BlockConstructor:
    def __init__(self, regstate):
        self.regstate = regstate
        self.sema = SemaList()
        self.nextpc = None
        self.tmp_counter = 0

    def get_tmp(self, width):
        res = SemaVar(width, 'tmp_{}'.format(self.tmp_counter))
        self.tmp_counter += 1
        return res

    def read_reg(self, reg):
        if isinstance(reg, (Register, RegisterSP, RegisterObservable, RegisterSpecial)):
            if reg.name not in self.regstate:
                return [], SemaVar(reg.width, 'arg_{}'.format(reg.name))
            return [], self.regstate[reg.name]
        elif isinstance(reg, RegisterPC):
            # XXX
            assert 0
        elif isinstance(reg, RegisterSplit):
            res = []
            val = SemaConst(reg.width, 0)
            for start, sub in reg.parts:
                sres, sval = self.read_reg(sub)
                res += sres
                val |= SemaZExt(sres, reg.width) << start
            return res, val
        elif isinstance(reg, SubRegister):
            res, rv = self.read_reg(reg.parent)
            return res, SemaExtr(rv, reg.start, reg.width)
        else:
            tmp = self.get_tmp(reg.width)
            return [
                SemaReadReg(tmp, reg),
            ], tmp


    def write_reg(self, cond, reg, val):
        assert reg.width == val.width
        if isinstance(reg, (Register, RegisterSP, RegisterObservable, RegisterSpecial)):
            ov = self.read_reg(reg)
            if cond is not None:
                self.regstate[reg.name] = SemaSlct(cond, val, ov)
            else:
                self.regstate[reg.name] = val
            if isinstance(reg, RegisterObservable) and ov != val:
                return [
                    SemaWriteReg(reg, val),
                ]
            return []
        elif isinstance(reg, RegisterPC):
            if cond is not None:
                if self.nextpc is None:
                    if self.cur_insn.base is None:
                        self.nextpc = self.cur_insn.end
                    else:
                        self.nextpc = self.cur_insn.base + self.cur_insn.end
                self.nextpc = SemaSlct(cond, val, self.nextpc)
            else:
                self.nextpc = val
            return []
        elif isinstance(reg, RegisterSplit):
            res = []
            for start, sub in reg.parts:
                res += self.write_reg(cond, sub, SemaExtr(val, start, sub.width))
            return res
        elif isinstance(reg, SubRegister):
            res, ov = self.read_reg(reg.parent)
            parts = []
            if reg.start != 0:
                parts.append(SemaExtr(ov, 0, reg.start))
            parts.append(val)
            end = reg.start + reg.width
            if end != reg.parent.width:
                parts.append(SemaExtr(ov, end, reg.parent.width - end))
            nv = SemaConcat(*parts)
            self.write_reg(cond, reg.parent, nv)
        else:
            return [
                SemaWriteReg(reg, val),
            ]

    def trans_sema(self, sema, prefix, cond, vstate):
        res = SemaList()
        for op in sema:
            def rebuilder_var(cls, *args):
                if cls is SemaVar:
                    width, name = args
                    if name in vstate:
                        vwidth, val = vstate[name]
                        assert width == vwidth
                        return val
                    else:
                        return cls(width, '{}_{}'.format(prefix, name))
                return cls(*args)
            if isinstance(op, SemaSet):
                assert cond is None
                src = op.src.rebuild(rebuilder_var)
                vstate[op.dst.name] = op.dst.width, src
            elif isinstance(op, SemaReadReg):
                rs, rv = self.read_reg(op.src)
                res += rs
                vstate[op.dst.name] = op.src.width, rv
            elif isinstance(op, SemaWriteReg):
                res += self.write_reg(cond, op.dst, op.src.rebuild(rebuilder_var))
            elif isinstance(op, SemaIfElse):
                op = SemaIfElse(
                    op.cond,
                    self.trans_sema(op.opsp, prefix, cond & op.cond, vstate),
                    self.trans_sema(op.opsp, prefix, cond & ~op.cond, vstate),
                )
                res.append(op)
            else:
                op = op.rebuild(rebuilder_var)
                res.append(op)
        return res

    def process_insn(self, insn, prefix):
        self.cur_insn = insn
        self.sema += self.trans_sema(insn.sema, prefix, None, {})

def do_bb(name, start, end):
    print("BB {}:".format(name))
    pos = start
    bc = BlockConstructor({})
    while end is None or pos < end:
        res = isa.parse(data, base, None, pos)
        if args.print_assembly or args.print_assembly_sema:
            print('{:08x} {:18} {}'.format(pos, ' '.join(format(x, '02x') for x in data[pos:pos+res.len]), (' '*28 + '\n').join(str(x) for x in res.insns)))
        if res.desync:
            break
        if args.print_assembly_sema:
            print(res.sema.str(0))
        bc.process_insn(res, 'insn_{:x}'.format(pos))
        pos += res.len
        if bc.nextpc is not None:
            break
    if args.print_assembly and not args.print_assembly_sema:
        print()
    print(bc.sema.str(0))
    for name, val in bc.regstate.items():
        print('${} = {}'.format(name, val))
    print()
    if bc.nextpc is not None:
        print('goto {}'.format(bc.nextpc))
    print()

bb_name = None
bb_start = None
bb_end = None

def flush_bb():
    global bb_name, bb_start, bb_end
    if bb_name is None:
        return
    do_bb(bb_name, bb_start, bb_end)
    bb_name= None
    bb_start = None
    bb_end = None

with open(args.file) as f:
    for l in f:
        l, _, _ = l.partition('#')
        p = l.split()
        if not p:
            continue
        cmd = p[0]
        if data is None:
            if cmd != 'file':
                raise ValueError('Expecting a file command')
            if len(p) not in {2, 3, 5}:
                raise ValueError('File command needs 1, 2, or 4 arguments')
            if len(p) > 2:
                base = int(p[2], 16)
            else:
                base = 0
            with open(p[1], "rb") as df:
                if len(p) > 3:
                    df.seek(int(p[3], 16))
                    sz = int(p[4], 16)
                    data = df.read(sz)
                    if len(data) != sz:
                        raise ValueError('not enough data in the file')
                else:
                    data = df.read()
                data = BinData(8, data)
        else:
            if cmd == 'bb':
                flush_bb()
                if len(p) not in {3, 4}:
                    raise ValueError('bb command needs 2 or 3 arguments')
                bb_name = p[1]
                bb_start = int(p[2], 16)
                if len(p) < 4:
                    bb_end = None
                else:
                    bb_end = int(p[3], 16)
            else:
                raise ValueError('Unknown command "{}"'.format(cmd))

flush_bb()
